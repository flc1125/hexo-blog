{"meta":{"title":"叶子坑","subtitle":"来也匆匆，去也匆匆","description":"叶子坑 | 来也匆匆，去也冲冲···","author":"叶子坑","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"docker nginx 搭建负载均衡","slug":"2018/09/docker-nginx-build-load-balancing","date":"2018-09-07T10:24:34.000Z","updated":"2018-09-07T10:24:39.000Z","comments":true,"path":"2018/09/docker-nginx-build-load-balancing.html","link":"","permalink":"http://yoursite.com/2018/09/docker-nginx-build-load-balancing.html","excerpt":"","text":"基于多个 Docker 容器 拉取 nginx 镜像docker pull nginx:alpine # 推荐 alpine 容器间通信官方提供的是 docker network 作为解决方案 docker netware create nginx # 创建名称 nginx 网络 创建容器 负载均衡，所以至少需要三个 nginx 容器 负载均衡器docker run -dit -v /nginx/:/nginx/ -p 80:80 --network nginx --network-alias master --name nginx-master nginx:alpine# 挂载目录仅演示目的 说明： --network nginx 使用 nginx 网络 --network-alias master 网络中的别名 宿主机对应 80 端口 WEB节点Adocker run -dit -v /nginx/:/nginx/ -p 8001:80 --network nginx --network-alias slave1 --name nginx-slave1 nginx:alpine# 8001 自定义，不重复即可 WEB节点Bdocker run -dit -v /nginx/:/nginx/ -p 8002:80 --network nginx --network-alias slave2 --name nginx-slave2 nginx:alpine# 8002 自定义，不重复即可 nginx 配置 仅列出核心部分代码 负载均衡器upstream web &#123; server slave1:80 weight=3; # weight 为权重 server slave2:80 weight=1;&#125;location / &#123; proxy_pass http://web;&#125; WEB节点A/Blocation / &#123; root /data/html; index index.html index.htm;&#125;","categories":[{"name":"运维","slug":"devops","permalink":"http://yoursite.com/categories/devops/"}],"tags":[]},{"title":"这个世界的女人和孩子","slug":"2018/08/women-and-children-of-this-world","date":"2018-08-01T01:12:55.000Z","updated":"2018-08-01T01:12:58.000Z","comments":true,"path":"2018/08/women-and-children-of-this-world.html","link":"","permalink":"http://yoursite.com/2018/08/women-and-children-of-this-world.html","excerpt":"","text":"作者 | 默尔索，独立批评人 来源 | 默尔索（ID：TheMeursault） 这是今年的第七次清零。 每次清零，都有两件事困扰我—— 其一，我不希望成为一个坏消息收集器，因为诚如你所见，坏消息总是比好消息多得多。当信息过载，遗忘是一种生理上的自我保护机制，不是喊几句“不要遗忘”就能避免的。因此，我需要摘取那些“坏消息中的坏消息”，而这种选择往往艰难。 其二，便是我个人的问题。看了太多坏消息，感到自己容易失语，因为理智告诉我，说什么都很微弱。我的书写对于那些遭遇坏事的人来说，并没有实际意义，既不能抚慰，也不能阻止相似的事件再次发生。如果我们注定要反复踏入同一条河流，也许都不必如此自苦，只需随波逐流，感恩幸存便好。 以上两种困扰，在这个七月达到顶峰。坏消息的涌来，如堤坝泄洪。其实，大多数讨论都是老生常谈，可以追溯到程朱甚至是孔孟时代。如果这些先贤都没有能力改变些许，那我无论做什么，想必也是徒劳。 所以，这一切只是用来记录。 01 / 这个世界的女人7月，印尼一名15岁的女孩儿被判入狱。她是一名强奸案的受害者，被自己哥哥强奸了8次。怀孕后，女孩儿偷偷堕胎，而这违反了印尼禁止女性堕胎的流产法。于是，这名女孩被判入狱六个月，而强奸她的哥哥，被判入狱两年。 7月，印度的一间法院里，50名律师围殴18名嫌疑人。这18人，有公寓保安，有电梯工人，有水管工，他们共同的罪名是轮奸了一位11岁的听障少女，且这一行为持续了7个月之久。当地的律师组织宣布，不为这18人提供任何辩护。 律师是法律的捍卫者，法院更是法律的圣殿。律师们在法院殴打嫌疑人，不一定证明他们法律意识淡薄，它可能揭示出另一种隐情：连律师们都不相信法律会给犯罪嫌疑人应有的惩罚，所以他们亲自施刑。 妇女权益保护运动的浩荡，取决于法律到底有多么滞后。在印尼和印度是如此，在仓廪更实、礼仪更重的中国，更是如此。 7月，中山大学教授张鹏被曝光，据说此公在2011~2017年之间，持续对女学生和女教师进行性骚扰，还涉嫌性侵一位大一女生。五名被骚扰过的女生联名向中山大学举报，校方回应：他们已针对此前收到的另一份举报，在4月对张鹏进行了党纪政纪处分。那意思是，我们已经做了所能做的，你们还想怎样。 可是，如果侵害一人和侵害十人的结果都只是一个处分，那何不侵害十人呢？校方之态度，完全没有让事件产生良性效应。 7月，南昌大学国学院副院长周斌被起诉。此前，他涉嫌猥亵、性侵一名女学生长达7个月之久，已被校方免职。如今，被侵犯的女生选择在法律层面解决问题，要求周斌赔偿心理康复治疗费，并支付精神抚慰金。同样被起诉的还有南昌大学本身。 这是中国首例学生就性侵问题起诉老师和学校的案件，很值得关注。其中一个细节是，女生的诉求只是经济赔偿，不包括让周斌接受法律制裁。两种诉求，按理说并不冲突，之所以选择一个舍弃一个，我们大抵也能猜出是为什么。 因为让他赔钱容易，让他坐牢太难。 在消失的4月清零中，我提供过这样一份名单： 北京航天航空大学教授 陈小武 对外经济贸易大学统计学院原副教授 薛原 北京师范大学教授 施雪华 南京师范大学社会发展学院教授 刘军 上海交通大学媒体与传播学院副院长 谢耕耘 南京大学语言学系主任 沈阳 加上中山大学的张鹏和南昌大学的周斌，这八个人，都曾涉嫌猥亵、性骚扰甚至性侵女学生。他们中大多都已调离教职，但还是请记住他们的名字，因为说不定什么时候，他们还会潜入你的身边。 高校并不是终点。 同样在7月，知名的公益人雷闯，知名的媒体人章文，知名的作家张弛，知名的环保领域大V冯永锋，知名的艾滋病权利活动家张锦雄，知名的公益活动家、《新周刊》的创始人孙冕，以及每年春晚都准时露面的知名主持人ZJ，都被曝光出有性骚扰和性侵犯方面的丑闻。 不是名人们的圈子恶心至极，而是聚光灯刚好打在那里。中国的“Me too”运动产生在高校和文化界，是因为这些地方有具有国际意识的新知识女性。在那些聚光灯照不到的地方，在那些女性意识没有觉醒到如此地步的地方，情况想必更加恶劣。上个月因被猥亵而自杀的甘肃高中女生，相信大家还不至于淡忘。 “Me too”运动被诟病最多的，是相关讨论缺乏标准和秩序，道德审判有狂欢化的倾向，仅就什么是性骚扰这个基础问题，许多人的理解也大不相同。有人认为，餐桌上调侃女性讲荤段子就是性骚扰，有人认为，只有上下其手跟踪偷窥才是性骚扰——大多数分歧，都是因为类似的标准不一。 我想，辩论式的讨论虽然必要，但真正的解药在别处：那就是让滞后的法律先进起来，让态度暧昧的执法机构强硬起来。 现行法律上，性骚扰不是一个罪名，只有猥亵妇女罪和强奸罪。猥亵妇女是五年以下，强奸是三年以上，十年以下。这个量刑尺度尚可，但翻翻相关定义，条件真是苛刻。猥亵罪需要满足一系列条件，比如妇女必须遭遇暴力胁迫或者恐吓欺骗，而且得有证据证明，“妇女明确表示拒绝”。 这个“明确拒绝”，相当要命，也相当操蛋，除非随时录音，否则我连明确拒绝电话推销都证明不了，更别说拒绝猥亵了。许多禽兽得以脱罪，也是因为这一点无法证明。更何况，许多案件根本走不到审判流程，取证困难之外，名人社会关系广杂，女性所承担的社会压力也容易让她们妥协，甚至执法机构都会劝说，希望大事化小。 这个立场上，我不喜欢那些执法者，因为他们太机灵。他们太懂那一套，如何掌控权力的松紧带，如何踢皮球，如何在灯光下勤勉，在黑暗中偷懒。这么说吧，我觉得某些中国执法者掌握着对自己生存有利的全部技能，唯独缺少执法者应有的正义感。 也许某一天，这些具体的事情都会被遗忘，但人们心中总会留下影影绰绰的印象：这个世界，对女性是危险的，不公正的。印度在这个问题上总被嘲笑，而如果这个印象不得到改观，我并不感到我们和印度有多大不同。 02 / 这个世界的孩子疫苗！疫苗！疫苗！ 不是长生科技和武汉科技，不是狂犬疫苗和百白破，不是那几十万支问题疫苗，我们质疑的是一切。因为疫苗出现问题，这种感觉就像吃出半条虫子，你我身上可能流淌着同样的失效疫苗，而这一切已经无法去证实。 许多话不方便讲，我改说个故事好了。 我曾经在超市里，看到一个孩子坐在地上哭嚷。他想吃巧克力，但严厉的母亲不愿给他，场面僵持，于是他就那样坐在地上哭嚷，撒泼打滚般，呼天抢地般，颜面尽失般。母亲则在一旁冷冷看着，仿佛他们素不相识。 你必然也见过类似的场景，或者你小时候就是这样的孩子也说不定。用成年人的视角看去，孩子在这场僵持中毫无胜算，那位母亲有太多方式可以处理这个问题，比如转移孩子的注意力，比如晓之以情动之以理，比如如我所见到的那样，采取冷暴力，实在不行，还可以换成“热暴力”，给上几巴掌，直接把孩子拎回家，关进小黑屋。 而孩子所能做的，只有哭嚷。 作为成年人，我理解那位母亲的感受。她兴许是手头拮据，兴许是家教严格，兴许是担心巧克力对牙齿不好，总之，她有无数个正当理由支持她的行为。但是，我同样曾是孩子，我知道在心智不全的儿童眼中，一件想要的东西，就是有天那么大，求之不得，便是天塌了。哭嚷，是他智力无法解决问题时所能采取的唯一方式。 什么让人成长呢？无外乎就是天一次一次地塌下来，孩子便长大了。 多年之后，孩子如果还记得这个哭嚷的瞬间，定会看穿自己的幼稚。他当时竟然认为，仅凭哭嚷便可动摇严厉的母亲，得到自己想要的东西。可事实上，情况从来都是另一番样子：哭嚷之后，一切照旧，对他来说，世界是以母亲的意志运转的，他并不是自己生活的主宰。 再过很多年，孩子长成大人，他会脱离母亲的掌控，但教育的烙印会伴他终生。那时的他，想必已深谙成人世界的运行法则，知道总有什么别的力量替他主宰命运。而此时，他已能完全控制自己，止住欲望，不再哭嚷。 哪怕不是最近的事件刺激，我也常常感到自己就是那个孩子。曾几何时，我也曾大声哭嚷，想要健康的牛奶鸡蛋，想要安全的大米蔬菜，想要宽松自由的表达环境。但是，那位母亲般的角色掌控一切，她想给我的，我便可以得到，她不想给我的，任由怎么哭嚷，都是徒劳。 假疫苗之殇，触动了每一个人的敏感神经。但我猜，你们想必都不难预料结果，公众号的文章写得再漂亮，记者的探访再卓绝，也改变不了整件事的大趋势：我们不是没打过假啊，今天打掉三聚氰胺牛奶，明天打掉苏丹红鸡蛋，后天打掉假疫苗，大后天打什么呢？打假在我们这变成了打地鼠，打掉这个冒出那个，扪心自问，我没那么长的命陪着玩。 打假应该是没什么条件可讲的，不能只打假牛奶假疫苗，不打假鞋假包。在区分利弊的前提下打假，假货就永远不会杜绝，因为大家有一个“制假售假买假”的共同商业逻辑。最近假货泛滥的拼多多突然崛起上市，谁在消费呢？从假鞋假包到假疫苗，我感到它们是同一个母亲的孩子。至少我是觉得，穿不起真耐克，可以穿真安踏，做不到管天管地，至少管好自己买真货、用正版、要授权。 不少人到中年的人，都有点生死置之度外的英雄气魄。打进去的疫苗抽不出来，“我们这辈子就这样了”，努力，主要是为下一代努力。打心眼里，我也希望“前事不忘后事之师”这句话真的有作用，不要让我们的后代走同样的路。 如果世间事总是这样循环往复，那我们人生的赛道就不是马拉松，而是驴拉磨。 03 / 其他 7月4日，电影《我不是药神》点映破亿，电影产生一句痛彻心扉的流行语：世界上只有一种病，穷病。 7月5日，载有143人两艘游船，在泰国倾覆。中国游客47人遇难。图为勇救4人的河南小伙张皓峰。 7月6日，为躲避加征关税，载有万吨大豆的美国货船“飞马峰号”，以最高时速冲向大连港，成为中美贸易战的绝佳注脚。 7月15日，世界杯闭幕，法国队时隔20年再获冠军。 7月25日，美国和欧盟在白宫达成关税互让协议，算上很可能加入的日本、加拿大和墨西哥在内，一个群名为“零关税自由贸易”的私聊群正在形成，群公告翻译出来应该就一句话：不带中国玩。 7月过去了。 原文： https://mp.weixin.qq.com/s?__biz=MTQzMjE1NjQwMQ==&amp;mid=2655548638&amp;idx=1&amp;sn=b3b7bc838364692344e0e4027e53a310&amp;chksm=66dfdb4051a852569d94398ee65dc0bda441e49e1c09a1e79e759bc3aff60dbd16ed6b1907d2&amp;mpshare=1&amp;scene=1&amp;srcid=0801YaO6sAYGGHcyozAGNECJ#rd","categories":[{"name":"转载","slug":"reproduce","permalink":"http://yoursite.com/categories/reproduce/"}],"tags":[]},{"title":"Travis CI & Github 自动化构建","slug":"2018/07/travis-ci-github-automated-build","date":"2018-07-26T16:00:00.000Z","updated":"2018-07-26T16:00:00.000Z","comments":true,"path":"2018/07/travis-ci-github-automated-build.html","link":"","permalink":"http://yoursite.com/2018/07/travis-ci-github-automated-build.html","excerpt":"","text":"起因个人文档（ http://docs.flc.io/ ）： 源文件托管至 Github （ https://github.com/flc1125/docs ）平台。但每次更新文档后都需要手动执行 mkdocs gh-deploy 发布至 gh-pages 分支才能访问。 为节省此操作和对环境软件的依赖，于是用起 Travis CI 持续化集成。 Github Token 用于 Travis 加入 Github 的授权使用 Token 创建地址: https://github.com/settings/tokens；勾选 repo 下所有选项。该 Token 不可暴露 Travis CI 如图勾选状态；点击 settings 进行配置 如图： A 输入变量名（名字随意）: GITHUB_TOKEN B 输入上文创建的 Token C 禁用，否则会在构建过程中暴露 Token 信息 .travis.yml在托管平台创建 .travis.yml 文件。写入下文（仅适用本文 docs 项目，具体自行研究） language: pythoncache: pippython: - \"3.6\"install: - pip install mkdocs - pip install mkdocs-material - pip install pygments - pip install pymdown-extensions - echo -e \"machine github.com\\n login $&#123;GITHUB_TOKEN&#125;\" &gt; ~/.netrc # 这个研究了好久script: - mkdocs gh-deploy --force --cleanbranches: only: - master 如此操作后，即可实现自动化构建；内容略粗糙，仅为了记录用。 相关文档 Travis加入Github认证操作：https://docs.travis-ci.com/user/customizing-the-build/#authentication 官方文档：https://docs.travis-ci.com/ GitHub Pageshttps://pages.github.com/","categories":[{"name":"运维","slug":"devops","permalink":"http://yoursite.com/categories/devops/"}],"tags":[]},{"title":"陆勇——《我不是药神》原型","slug":"2018/07/795","date":"2018-07-06T16:00:00.000Z","updated":"2018-07-06T16:00:00.000Z","comments":true,"path":"2018/07/795.html","link":"","permalink":"http://yoursite.com/2018/07/795.html","excerpt":"","text":"陆勇，是中国大陆江苏省无锡市一家针织品出口企业的老板，慢性粒细胞性白血病患者。因所服用的治疗慢性粒细胞性白血病的格列卫（伊马替尼）价格过于高昂，家中积蓄几乎要掏空。后陆勇发现一款印度仿制药“格列卫”，疗效相似，陆勇自己先开始服用仿制药，发现确实有效后，介绍给其他白血病患者，并到印度购买“格列卫”（伊马替尼）的仿制药。不过在中国，陆勇所购买的印度仿制药没有批文、不具备合法渠道，因此被药监部门定性为“假药”。除此之外，由于境外汇款手续麻烦，为方便陆勇和病友购药，陆勇通过淘宝以500元每套的价格购买了3张银行借记卡，这一行为又构成了妨害信用卡管理罪。2013年，湖南省沅江市公安局在查办一网络银行卡贩卖团伙发现使用银行卡进行交易的陆勇。2015年1月10日晚，被警察以妨害信用卡管理犯罪、销售假药罪逮捕。陆勇被捕后有数百名患者联名上书，请求免除对陆的起诉。2015年1月27日检察机关向法院申请撤销起诉，同天法院撤销起诉。2015年1月29日陆勇获释。 2018年，他的故事被拍成电影《我不是药神》。","categories":[{"name":"分享","slug":"share","permalink":"http://yoursite.com/categories/share/"}],"tags":[]},{"title":"CTF大赛-阿笠博士的兔子","slug":"2018/07/788","date":"2018-07-02T16:00:00.000Z","updated":"2018-07-02T16:00:00.000Z","comments":true,"path":"2018/07/788.html","link":"","permalink":"http://yoursite.com/2018/07/788.html","excerpt":"","text":"题目来源于公司第三届（2018年）的CTF大赛题之一，分值：200 题目柯南立刻想起阿笠博士培养出一对繁殖能力超强的兔子（雌雄），这种兔子嗅觉特别好，能快速找到丢失的镇馆之宝，这种兔子出生后一个月就会成年，成年的兔子再过一个月会生一对（雌雄）兔子，并且之后的每个月都会生一对兔子，兔子不会死亡，由于这种兔子一生只有一个伴侣，当兔子数量（对）越多对找回的镇馆之宝帮助最大，阿笠博士想知道当兔子数量（对）第11次出现素数之后过再128个月有多少对兔子，机智你能帮阿笠博士算出来吗？ 解答&lt;?phpclass App&#123; /** * 当前第几个月 * * @var int */ protected $m = 0; /** * 需要处理的剩余月数 * * @var int */ protected $remain = 128; /** * 兔纸对数 * * @var int */ protected $num = 1; /** * 出现质数的次数 * * @var int */ protected $z = 0; /** * 上一次的数量 * * @var int */ protected $prev = 0; /** * 处理 * * @return [type] [description] */ public function handle() &#123; while ($this-&gt;remain) &#123; // A. 月数增加 ++$this-&gt;m; // 这个属性没啥用，只是为了凸显我电脑性能好 // B. 兔纸增加 $prev = $this-&gt;num; // 上个月的数量 $this-&gt;num = bcadd($this-&gt;num, $this-&gt;prev); // 当月数量 bcadd避免换算成科学计算显示方式 $this-&gt;prev = $prev; // 用于下次计算的上个月数量 // C. 如果z为11次时，则逐月递减 if ($z == 11) &#123; --$this-&gt;remain; &#125; // D. 判断是否为质数 if ($z &lt; 11 &amp;&amp; $this-&gt;isPrime($this-&gt;num)) &#123; ++$z; &#125; &#125; return $this-&gt;num; &#125; /** * 判断是否为质数（素数） * * NOTE：方法来源其他网友 * * @param [type] $n [description] * * @return bool [description] */ protected function isPrime($n) &#123; if ($n &lt;= 3) &#123; return $n &gt; 1; &#125; elseif ($n % 2 === 0 || $n % 3 === 0) &#123; // 排除能被2整除的数(2x)和被3整除的数(3x) return false; &#125; // 排除能被6x+1和6x+5整除的数 for ($i = 5; $i * $i &lt;= $n; $i += 6) &#123; if ($n % $i === 0 || $n % ($i + 2) === 0) &#123; return false; &#125; &#125; return true; &#125;&#125;$app = new App();echo $app-&gt;handle();","categories":[{"name":"PHP","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"国立西南联合大学","slug":"2018/06/779","date":"2018-06-01T16:00:00.000Z","updated":"2018-06-01T16:00:00.000Z","comments":true,"path":"2018/06/779.html","link":"","permalink":"http://yoursite.com/2018/06/779.html","excerpt":"","text":"电影《无问西东》，讲了四个年代，四代青年的故事。最感动大家的是第二段：一个特殊的时期，一个特殊的大学。若要说100年来中国最牛的大学，确切的说，不是北大，也不是清华，而应该是——国立西南联合大学… 查看更多… 百科介绍 百度VR体验： 体验效果有bug，展示的素材不是很严谨。。看看就好","categories":[{"name":"分享","slug":"share","permalink":"http://yoursite.com/categories/share/"}],"tags":[]},{"title":"php-cs-fixer 自动化规范PHP代码","slug":"2018/05/746","date":"2018-05-12T16:00:00.000Z","updated":"2018-05-12T16:00:00.000Z","comments":true,"path":"2018/05/746.html","link":"","permalink":"http://yoursite.com/2018/05/746.html","excerpt":"","text":"php-cs-fixer 是一个支持自定义，自动化规范PHP代码的组件， 使用教程参考官网：http://cs.sensiolabs.org/ 参考命令php-cs-fixer fix --config=.php_cs -v --using-cache=no --path-mode=intersection -- PHP文件路径 大部分编辑器可安装相关扩展，以支持快捷键执行格式化。如 Sublime： PHP CS Fixer 参考配置 配置存项目根目录 .php_cs 即可 &lt;?phpreturn PhpCsFixer\\Config::create() -&gt;setRiskyAllowed(true) -&gt;setRules(array( '@Symfony' =&gt; true, 'array_syntax' =&gt; array('syntax' =&gt; 'short'), 'ordered_imports' =&gt; true, 'phpdoc_order' =&gt; true, 'no_useless_else' =&gt; true, 'no_useless_return' =&gt; true, 'php_unit_construct' =&gt; true, 'php_unit_strict' =&gt; true, 'yoda_style' =&gt; false, 'phpdoc_summary' =&gt; false, 'not_operator_with_successor_space' =&gt; true, 'no_extra_consecutive_blank_lines' =&gt; true, 'general_phpdoc_annotation_remove' =&gt; true, // 'ordered_class_elements' =&gt; true, 'binary_operator_spaces' =&gt; array( // 'align_double_arrow' =&gt; true, // 'align_equals' =&gt; true, 'default' =&gt; 'align_single_space_minimal', ), )) -&gt;setFinder( PhpCsFixer\\Finder::create() -&gt;exclude('_*') -&gt;exclude('vendor') -&gt;exclude('storage') -&gt;exclude('resources') -&gt;exclude('public') -&gt;in(__DIR__) );","categories":[{"name":"PHP","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"基于Laravel的API服务端架构代码","slug":"2016/08/549","date":"2016-08-02T16:00:00.000Z","updated":"2016-08-02T16:00:00.000Z","comments":true,"path":"2016/08/549.html","link":"","permalink":"http://yoursite.com/2016/08/549.html","excerpt":"","text":"开源地址：https://github.com/flc1125/ApiServer注：现有API基于laravel框架开发，本次介绍也针对laravel。可根据文档自行调整，以适用其他框架下使用 部署说明数据库相关执行如下SQL语句 CREATE TABLE `prefix_apps` ( `id` INT(10) NOT NULL AUTO_INCREMENT COMMENT '自增长', `app_id` VARCHAR(60) NOT NULL COMMENT 'appid', `app_secret` VARCHAR(100) NOT NULL COMMENT '密钥', `app_name` VARCHAR(200) NOT NULL COMMENT 'app名称', `app_desc` TEXT COMMENT '描述', `status` TINYINT(2) DEFAULT '0' COMMENT '生效状态', `created_at` INT(10) NOT NULL DEFAULT '0' COMMENT '创建时间', `updated_at` INT(10) NOT NULL DEFAULT '0' COMMENT '更新时间', PRIMARY KEY (`id`), UNIQUE KEY `app_id` (`app_id`), KEY `status` (`status`)) ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT='应用表'; 目录相关 标题 路径 API核心目录 app/Services/ApiServer/ API接口目录 app/Services/ApiServer/Response/ apps数据库模型 app/Models/App.php 路由配置 app/Http/routes.php API入口控制器 app/Http/Controllers/Api/RouterController.php API文档及开发规范API调用协议请求地址及请求方式 请求地址：/api/router; 请求方式：POST/GET 公共参数 参数名 类型 是否必须 描述 app_id string 是 应用ID method string 是 接口名称 format string 否 回调格式，默认：json（目前仅支持） sign_method string 否 签名类型，默认：md5（目前仅支持） nonce string 是 随机字符串，长度1-32位任意字符 sign string 是 签名字符串，参考签名规则 业务参数 API调用除了必须包含公共参数外，如果API本身有业务级的参数也必须传入，每个API的业务级参数请考API文档说明。 签名规则 对所有API请求参数（包括公共参数和请求参数，但除去sign参数），根据参数名称的ASCII码表的顺序排序。如：foo=1, bar=2, foo_bar=3, foobar=4排序后的顺序是bar=2, foo=1, foo_bar=3, foobar=4。 将排序好的参数名和参数值拼装在一起，根据上面的示例得到的结果为：bar2foo1foo_bar3foobar4。 把拼装好的字符串采用utf-8编码，使用签名算法对编码后的字节流进行摘要。如果使用MD5算法，则需要在拼装的字符串前后加上app的secret后，再进行摘要，如：md5(secret+bar2foo1foo_bar3foobar4+secret) 将摘要得到的字节结果使用大写表示 返回结果// 成功&#123; \"status\": true, \"code\": \"200\", \"msg\": \"成功\", \"data\": &#123; \"time\": \"2016-08-02 12:07:09\" &#125;&#125;// 失败&#123; \"status\": false, \"code\": \"1001\", \"msg\": \"[app_id]缺失\"&#125; API开发规范API接口命名规范（method） 接口名称统一小写字母 多单词用.隔开 对应的类文件（目录：app/Services/ApiServer/Response/）；以接口名去.，再首字母大写作为类名及文件名。如接口名：user.add，对应的类文件及类名为：UserAdd 接口命名规范 命名字母按功能或模块从大到小划分，依次编写；如后台用户修改密码：’admin.user.password.update’ 字母最后单词为操作。查询:get;新增:add;更新:update;删除:delete;上传:upload;等 错误码 错误码配置：app/Services/ApiServer/Error.php 命名规范： 类型 长度 说明 系统码 3 同http状态码 公共错误码 4 公共参数错误相关的错误码 业务错误码 6+ 2位业务码+4位错误码，不足补位 现有错误码： 错误码 错误内容 200 成功 400 未知错误 401 无此权限 500 服务器异常 1001 [app_id]缺失 1002 [app_id]不存在或无权限 1003 [method]缺失 1004 [format]错误 1005 [sign_method]错误 1006 [sign]缺失 1007 [sign]签名错误 1008 [method]方法不存在 1009 run方法不存在，请联系管理员 1010 [nonce]缺失 1011 [nonce]必须为字符串 1012 [nonce]长度必须为1-32位 API DEMO 示例文件路径：app/Services/ApiServer/Response/Demo.php","categories":[{"name":"PHP","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"PHP","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"Laravel","slug":"laravel","permalink":"http://yoursite.com/tags/laravel/"},{"name":"API","slug":"api","permalink":"http://yoursite.com/tags/api/"}]},{"title":"小学题：啤酒2块1瓶，4个盖换1瓶，2个空瓶换1瓶，10块可以喝几瓶?","slug":"2015/11/286","date":"2015-11-05T16:00:00.000Z","updated":"2015-11-05T16:00:00.000Z","comments":true,"path":"2015/11/286.html","link":"","permalink":"http://yoursite.com/2015/11/286.html","excerpt":"","text":"题目小学题：啤酒2块1瓶，4个盖换1瓶，2个空瓶换1瓶，10块可以喝几瓶？ 解答&lt;?php/** * 小学题：啤酒2块1瓶，4个盖换1瓶，2个空瓶换1瓶，10块可以喝几瓶? * @param number $money 多少钱 * @return int */function getNumber($money)&#123; $a = 2; //啤酒价格 $b = 0; //已经买了的酒数量 $c = 4; //多少个盖子换一瓶 $d = 2; //多少个空瓶子换一瓶 $e = 0; //有多少个盖子 $f = 0; //有多少个空瓶 $b = (int) ($money / $a); // 一开始买了多少瓶 $e = $b; $f = $b; // 开始循环换盖子和空瓶子 while( $e &gt;= $c || $f &gt;= $d) &#123; // 换盖子 if ($e &gt;= $c) &#123; $e -= $c; $b++; $e++; $f++; &#125; // 换瓶子 if ($f &gt;= $d) &#123; $f -= $d; $b++; $e++; $f++; &#125; &#125; return array('RMB' =&gt; $money, '啤酒数量' =&gt; $b, '剩余瓶盖数量' =&gt; $e, '剩余空瓶数量' =&gt; $f);&#125;$rs = getNumber(10);print_r($rs);?&gt; 返回结果： Array( [RMB] =&gt; 10 [啤酒数量] =&gt; 15 [剩余瓶盖数量] =&gt; 3 [剩余空瓶数量] =&gt; 1)","categories":[{"name":"PHP","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"php注释标准","slug":"2015/10/248","date":"2015-10-26T16:00:00.000Z","updated":"2015-10-26T16:00:00.000Z","comments":true,"path":"2015/10/248.html","link":"","permalink":"http://yoursite.com/2015/10/248.html","excerpt":"","text":"规范注释标准注释 &lt;?php/** * 标题及说明 * * @author 作者 &lt;邮箱&gt; * @param 参数数据类型 参数变量 参数说明 * * @return 返回数据类型 返回说明 */ 注： 其中前端应用中参数数据类型，為区分参数变量，会加上{}，如：{参数数据类型} 例子 &lt;?php/** * 加法计算 * * @author 作者 &lt;邮箱&gt; * @param number $m 参数1 * @param number $n 参数2 * * @return number */function calc($m, $n)&#123; return $m + $n;&#125; 数据类型 标识 说明 integer 或 int 整数类型 boolean 或 bool 布尔值类型 number 数字 string 字符串 array 数组 object 对象 mixed 混合类型 void 空类型 文档标记 文档标记的使用范围是指该标记可以用来修饰的关键字，或其他文档标记。 所有的文档标记都是在每一行的 * 后面以@开头。如果在一段话的中间出来@的标记，这个标记将会被当做普通内容而被忽略掉。 &lt;?php/** * @name 名字 * @abstract 申明变量/类/方法 * @access 指明这个变量、类、函数/方法的存取权限 * @author 函数作者的名字和邮箱地址 * @category 组织packages * @copyright 指明版权信息 * @const 指明常量 * @deprecate 指明不推荐或者是废弃的信息 * @example 示例 * @exclude 指明当前的注释将不进行分析，不出现在文挡中 * @final 指明这是一个最终的类、方法、属性，禁止派生、修改。 * @global 指明在此函数中引用的全局变量 * @include 指明包含的文件的信息 * @link 定义在线连接 * @module 定义归属的模块信息 * @modulegroup 定义归属的模块组 * @package 定义归属的包的信息 * @param 定义函数或者方法的参数信息 * @return 定义函数或者方法的返回信息 * @see 定义需要参考的函数、变量，并加入相应的超级连接。 * @since 指明该api函数或者方法是从哪个版本开始引入的 * @static 指明变量、类、函数是静态的。 * @throws 指明此函数可能抛出的错误异常,极其发生的情况 * @todo 指明应该改进或没有实现的地方 * @var 定义说明变量/属性。 * @version 定义版本信息 */ @access 使用范围：class,function,var,define,module 该标记用于指明关键字的存取权限：private、public或proteced @author 指明作者 @copyright 使用范围：class，function，var，define，module，use 指明版权信息 @deprecated 使用范围：class，function，var，define，module，constent，global，include 指明不用或者废弃的关键字 @example 该标记用于解析一段文件内容，并将他们高亮显示。Phpdoc会试图从该标记给的文件路径中读取文件内容 @const 使用范围：define 用来指明php中define的常量 @final 使用范围：class,function,var 指明关键字是一个最终的类、方法、属性，禁止派生、修改。 @filesource 和example类似，只不过该标记将直接读取当前解析的php文件的内容并显示。 @global 指明在此函数中引用的全局变量 @ingore 用于在文档中忽略指定的关键字 @license 许可权 @link 类似于license；但还可以通过link指到文档中的任何一个关键字 @name 为关键字指定一个别名。 @package 使用范围：页面级别的-&gt; define，function，include 类级别的-&gt;class，var，methods 用于逻辑上将一个或几个关键字分到一组。 @abstrcut 说明当前类是一个抽象类 @param 指明一个函数的参数 @return 指明一个方法或函数的返回指 @static 指明关建字是静态的。 @var 指明变量类型 @version 指明版本信息 @todo 指明应该改进或没有实现的地方 @throws 指明此函数可能抛出的错误异常,极其发生的情况 上面提到过，普通的文档标记标记必须在每行的开头以@标记，除此之外，还有一种标记叫做inline tag,用{@}表示，具体包括以下几种： {@link} 用法同@link {@source} 显示一段函数或方法的内容","categories":[{"name":"PHP","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[]},{"title":"javascript立即调用的函数表达式","slug":"2015/10/216","date":"2015-10-24T16:00:00.000Z","updated":"2015-10-24T16:00:00.000Z","comments":true,"path":"2015/10/216.html","link":"","permalink":"http://yoursite.com/2015/10/216.html","excerpt":"","text":"前言大家学JavaScript的时候，经常遇到自执行匿名函数的代码，今天我们主要就来想想说一下自执行。 在详细了解这个之前，我们来谈了解一下“自执行”这个叫法，本文对这个功能的叫法也不一定完全对，主要是看个人如何理解，因为有的人说立即调用，有的人说自动执行，所以你完全可以按照你自己的理解来取一个名字，不过我听很多人都叫它为“自执行”，但作者后面说了很多，来说服大家称呼为“立即调用的函数表达式”。 本文英文原文地址：http://benalman.com/news/2010/11/immediately-invoked-function-expression/ 什么是自执行？在 JavaScript 里，任何 function 在执行的时候都会创建一个执行上下文，因为为 function 声明的变量和 function 有可能只在该 function 内部，这个上下文，在调用 function 的时候，提供了一种简单的方式来创建自由变量或私有子 function。 // 由于该function里返回了另外一个function，其中这个function可以访问自由变量i// 所有说，这个内部的function实际上是有权限可以调用内部的对象。function makeCounter() &#123; // 只能在makeCounter内部访问i var i = 0; return function () &#123; console.log(++i); &#125;;&#125;// 注意，counter和counter2是不同的实例，分别有自己范围内的i。var counter = makeCounter();counter(); // logs: 1counter(); // logs: 2var counter2 = makeCounter();counter2(); // logs: 1counter2(); // logs: 2alert(i); // 引用错误：i没有defind（因为i是存在于makeCounter内部）。 很多情况下，我们不需要 makeCounter 多个实例，甚至某些 case 下，我们也不需要显示的返回值，OK，往下看。 问题的核心当你声明类似 function foo(){} 或 var foo = function(){} 函数的时候，通过在后面加个括弧就可以实现自执行，例如 foo() ，看代码： // 因为想下面第一个声明的function可以在后面加一个括弧()就可以自己执行了，比如foo()，// 因为foo仅仅是function() &#123; /* code */ &#125;这个表达式的一个引用 var foo = function()&#123; /* code */ &#125; // ...是不是意味着后面加个括弧都可以自动执行？ function()&#123; /* code */ &#125;(); // SyntaxError: Unexpected token (// 上述代码，如果甚至运行，第2个代码会出错，因为在解析器解析全局的 function 或者 function 内部 function 关键字的时候，默认是认为 function 声明，而不是 function 表达式，如果你不显示告诉编译器，它默认会声明成一个缺少名字的 function ，并且抛出一个语法错误信息，因为 function 声明需要一个名字。 旁白：函数(function)，括弧(paren)，语法错误(SyntaxError)有趣的是，即便你为上面那个错误的代码加上一个名字，他也会提示语法错误，只不过和上面的原因不一样。在一个表达式后面加上括号()，该表达式会立即执行，但是在一个语句后面加上括号()，是完全不一样的意思，他的只是分组操作符。 // 下面这个function在语法上是没问题的，但是依然只是一个语句// 加上括号()以后依然会报错，因为分组操作符需要包含表达式 function foo()&#123; /* code */ &#125;(); // SyntaxError: Unexpected token ) // 但是如果你在括弧()里传入一个表达式，将不会有异常抛出// 但是foo函数依然不会执行function foo()&#123; /* code */ &#125;( 1 ); // 因为它完全等价于下面这个代码，一个function声明后面，又声明了一个毫无关系的表达式： function foo()&#123; /* code */ &#125; ( 1 ); 你可以访问 ECMA-262-3 in detail. Chapter 5. Functions 获取进一步的信息。 自执行函数表达式要解决上述问题，非常简单，我们只需要用大括弧将代码的代码全部括住就行了，因为 JavaScript 里括弧 () 里面不能包含语句，所以在这一点上，解析器在解析 function 关键字的时候，会将相应的代码解析成 function 表达式，而不是 function 声明。 // 下面2个括弧()都会立即执行(function () &#123; /* code */ &#125; ()); // 推荐使用这个(function () &#123; /* code */ &#125;)(); // 但是这个也是可以用的// 由于括弧()和JS的&amp;&amp;，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了// 不过，请注意下一章节的内容解释var i = function () &#123; return 10; &#125; ();true &amp;&amp; function () &#123; /* code */ &#125; ();0, function () &#123; /* code */ &#125; ();// 如果你不在意返回值，或者不怕难以阅读// 你甚至可以在function前面加一元操作符号!function () &#123; /* code */ &#125; ();~function () &#123; /* code */ &#125; ();-function () &#123; /* code */ &#125; ();+function () &#123; /* code */ &#125; ();// 还有一个情况，使用new关键字,也可以用，但我不确定它的效率// http://twitter.com/kuvos/status/18209252090847232new function () &#123; /* code */ &#125;new function () &#123; /* code */ &#125; () // 如果需要传递参数，只需要加上括弧() 上面所说的括弧是消除歧义的，其实压根就没必要，因为括弧本来内部本来期望的就是函数表达式，但是我们依然用它，主要是为了方便开发人员阅读，当你让这些已经自动执行的表达式赋值给一个变量的时候，我们看到开头有括弧(，很快就能明白，而不需要将代码拉到最后看看到底有没有加括弧。 用闭包保存状态和普通 function 执行的时候传参数一样，自执行的函数表达式也可以这么传参，因为闭包直接可以引用传入的这些参数，利用这些被 lock 住的传入参数，自执行函数表达式可以有效地保存状态。 // 这个代码是错误的，因为变量i从来就没背locked住// 相反，当循环执行以后，我们在点击的时候i才获得数值// 因为这个时候i操真正获得值// 所以说无论点击那个连接，最终显示的都是I am link #10（如果有10个a元素的话）var elems = document.getElementsByTagName('a');for (var i = 0; i &lt; elems.length; i++) &#123; elems[i].addEventListener('click', function (e) &#123; e.preventDefault(); alert('I am link #' + i); &#125;, 'false');&#125;// 这个是可以用的，因为他在自执行函数表达式闭包内部// i的值作为locked的索引存在，在循环执行结束以后，尽管最后i的值变成了a元素总数（例如10）// 但闭包内部的lockedInIndex值是没有改变，因为他已经执行完毕了// 所以当点击连接的时候，结果是正确的var elems = document.getElementsByTagName('a');for (var i = 0; i &lt; elems.length; i++) &#123; (function (lockedInIndex) &#123; elems[i].addEventListener('click', function (e) &#123; e.preventDefault(); alert('I am link #' + lockedInIndex); &#125;, 'false'); &#125;)(i);&#125;// 你也可以像下面这样应用，在处理函数那里使用自执行函数表达式// 而不是在addEventListener外部// 但是相对来说，上面的代码更具可读性var elems = document.getElementsByTagName('a');for (var i = 0; i &lt; elems.length; i++) &#123; elems[i].addEventListener('click', (function (lockedInIndex) &#123; return function (e) &#123; e.preventDefault(); alert('I am link #' + lockedInIndex); &#125;; &#125;)(i), 'false');&#125; 其实，上面2个例子里的 lockedInIndex 变量，也可以换成 i，因为和外面的i不在一个作用于，所以不会出现问题，这也是匿名函数 + 闭包的威力。 自执行匿名函数和立即执行的函数表达式区别在这篇帖子里，我们一直叫自执行函数，确切的说是自执行匿名函数（Self-executing anonymous function），但英文原文作者一直倡议使用立即调用的函数表达式（Immediately-Invoked Function Expression）这一名称，作者又举了一堆例子来解释，好吧，我们来看看： // 这是一个自执行的函数，函数内部执行自身，递归function foo() &#123; foo(); &#125;// 这是一个自执行的匿名函数，因为没有标示名称// 必须使用arguments.callee属性来执行自己var foo = function () &#123; arguments.callee(); &#125;;// 这可能也是一个自执行的匿名函数，仅仅是foo标示名称引用它自身// 如果你将foo改变成其它的，你将得到一个used-to-self-execute匿名函数var foo = function () &#123; foo(); &#125;;// 有些人叫这个是自执行的匿名函数（即便它不是），因为它没有调用自身，它只是立即执行而已。(function () &#123; /* code */ &#125; ());// 为函数表达式添加一个标示名称，可以方便Debug// 但一定命名了，这个函数就不再是匿名的了(function foo() &#123; /* code */ &#125; ());// 立即调用的函数表达式（IIFE）也可以自执行，不过可能不常用罢了(function () &#123; arguments.callee(); &#125; ());(function foo() &#123; foo(); &#125; ());// 另外，下面的代码在黑莓5里执行会出错，因为在一个命名的函数表达式里，他的名称是undefined// 呵呵，奇怪(function foo() &#123; foo(); &#125; ()); 希望这里的一些例子，可以让大家明白，什么叫自执行，什么叫立即调用。 注： arguments.callee 在 ECMAScript 5 strict mode 里被废弃了，所以在这个模式下，其实是不能用的。 最后的旁白：Module模式在讲到这个立即调用的函数表达式的时候，我又想起来了Module模式，如果你还不熟悉这个模式，我们先来看看代码： // 创建一个立即调用的匿名函数表达式// return一个变量，其中这个变量里包含你要暴露的东西// 返回的这个变量将赋值给counter，而不是外面声明的function自身var counter = (function () &#123; var i = 0; return &#123; get: function () &#123; return i; &#125;, set: function (val) &#123; i = val; &#125;, increment: function () &#123; return ++i; &#125; &#125;;&#125; ());// counter是一个带有多个属性的对象，上面的代码对于属性的体现其实是方法counter.get(); // 0counter.set(3);counter.increment(); // 4counter.increment(); // 5counter.i; // undefined 因为i不是返回对象的属性i; // 引用错误: i 没有定义（因为i只存在于闭包） 关于更多 Module 模式的介绍，请访问我的上一篇帖子：深入理解JavaScript系列（2）：全面解析Module模式 。 更多阅读希望上面的一些例子，能让你对立即调用的函数表达（也就是我们所说的自执行函数）有所了解，如果你想了解更多关于function和Module模式的信息，请继续访问下面列出的网站： ECMA-262-3 in detail. Chapter 5. Functions. – Dmitry A. Soshnikov Functions and function scope – Mozilla Developer Network Named function expressions – Juriy “kangax” Zaytsev 全面解析Module模式 – Ben Cherry（大叔翻译整理） Closures explained with JavaScript – Nick Morgan 原文：http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html","categories":[{"name":"转载","slug":"reproduce","permalink":"http://yoursite.com/categories/reproduce/"}],"tags":[]},{"title":"百万级PHP网站架构工具箱，高并发架构方案","slug":"2015/08/190","date":"2015-08-27T16:00:00.000Z","updated":"2015-08-27T16:00:00.000Z","comments":true,"path":"2015/08/190.html","link":"","permalink":"http://yoursite.com/2015/08/190.html","excerpt":"","text":"在了解过世界最大的PHP站点，Facebook的后台技术后，今天我们来了解一个百万级PHP站点的网站架构：Poppen.de。Poppen.de是德国的一个社交网站，相对Facebook、Flickr来说是一个很小的网站，但它有一个很好的架构，融合了很多技术，如 Nigix、MySql、CouchDB、Erlang、Memcached、RabbitMQ、PHP、Graphite、Red5以及Tsung。 Poppen.de目前有200万注册用户数、2万并发用户数、每天20万条私有消息、每天25万登录次数。而项目团队有11个开发人员，两个设计，两个系统管理员。该站点的商业模式采用免费增值模式，用户可以使用搜索用户、给好友发送消息、上载图片和视频等功能。 如果用户想享受不受限制发送消息和上载图片，那么就得根据需要支付不同类型的会员服务，视频聊天及网站其他服务也采用同样的策略。 NginxPoppen.de 所有的服务都是基于Nginx服务上的。前端有两台Nginx服务器在高峰期提供每分钟15万次请求的负载，每个机器已经有四年寿命，并且只有一个CPU 和 3GBRAM。Poppen.de拥有三台独立的图像服务器，由三台Nginx服务器为 *.bilder.poppen.de 提供每分钟8万次请求服务。 Nginx 架构中一个很酷的设计就是有很多请求是由Memcached处理的，因此请求从缓存中获取内容而不需要直接访问PHP机器。比如，用户信息页(user profile)是网站需要密集处理的内容，如果把用户信息页全部缓存到Memcached上，那么请求直接从Memcached上获取内容。 Poppen.de的Memcached每分钟可以处理8000次请求。 架构中有三个Nginx图像服务器提供本地图像缓存，用户上载图 像到一个中央文件服务器。当向这三个Nginx之一中请求图像时，如果服务器本地中没有存在该图像，则从中央文件服务器下载到该服务器上作缓存并提供服 务。这种负载均衡的分布式图像服务器架构设计可以减轻主要存储设备的负载。 PHP-FPM该网站运行在PHP- FPM上。共有28台双CPU、6GB内存的PHP机器，每个机器上运行100个PHP-FPM的工作线程。使用启用了APC的PHP5.3.x。 PHP5.3可以降低CPU和内存使用率的30%以上。 程序代码是基于Symfony1.2框架之上开发的。一是可以使用外部资源，二是能够提高项目开发进度，同时在一个著名的框架上可以让新开发人员更容易加入到团队中来。虽然没有任何事情都是十全十美的，但可以从Symfony框架中得 到很多好处，让团队可以更多的精力放在Poppen.de的业务开发上去。 网站性能优化使用XHProf，这是Facebook开源出来的一个类库。这个框架非常容易个性化和配置，能够可以缓存大部分高代价的服务器计算。 MySQLMySQL是网站主要的RDBMS。网站又几个MySql服务器：一台4CPU、32GB的服务器存储用户相关信息，如基本信息、照片描述信息等。这台机器已经使用了4年，下一步计划会使用共享集群来替换它。目前仍基于这个系统上进行设计，以简化数据访问代码。根据用户ID进行数据分区，因为网站中大部分信息都是以用户 为中心的，如照片、视频、消息等。 有三台服务器按主-从-从配置架构提供用户论坛服务。一台从服务器负责网站自定义消息存储，到现在有2.5亿条消息。另外四台机器为主-从配置关系。另外由4台机器配置成NDB族群专门服务于密集型写操作数据，如用户访问统计信息。 数据表设计尽量避免关联操作，尽可能缓存最多的数据。当然，数据库的结构化规范已经完全被破坏掉了。因此，为了更容易搜索，数据库设计创建了数据挖掘表。大部分表是MyISAM型表，可以提供快速查找。现在的问题是越来越多的表已经全表锁住了。Poppen.de正考虑往XtraDB存储引擎上迁移。 Memcached网站架构中Memcached应用相当多，超过45GB的高速缓存和51个节点。缓存了Session会话、视图缓存以及函数执行缓存等。架构中有一个系统当记录被修改时可以自动地把数据更新到缓存中去。未来改善缓存更新的可能方案是使用新的Redis Hash API或者MongoDB。 RabbitMQ在 2009年中开始在架构中使用RabbitMQ。这是一个很好的消息解决方案，便于部署和集中到这个架构中去，在LVS后运行了两台RabbitMQ服务器。在上个月，已经把更多的东西集成到该队列中，意味着同一时刻有28台PHP服务器每天要处理50万次请求。发送日志、邮件通知、系统消息、图像上载等 更多的东西到这个队列中。 应用PHP-FPM中的fastcgi_finish_request()函数集成队列消息，可以把消息异步发 送到队列中。当系统需要给用户发送HTML或JSON格式响应时，就调用这个函数，这样用户就没有必要等到PHP脚本清理。 这个系统可以改善架构资源管理。例如，在高峰期服务每分钟可以处理1000次登录请求。这表示有1000并发更新用户表保存用户的登录时间。由于使用了队列机制，可以按相反的顺序来运行这些查询。如果需要提高处理速度，只需要增加更多的队列处理者即可，甚至可以增加更多的服务器到这集群中去，而不需要修改任何配置和部 署新节点。 CouchDB日志存储CouchDB运行在一台机器上。在这台机器上可以根据模块/行为进行日志查询 / 分组，或者根据错误类型等等。这对定位问题非常有用。在使用日志聚合服务CouchDB之前，不得不逐台登录到PHP服务器上设法日志分析定位问题，这是非常麻烦的。而现在把所有的日志集中到队列中保存到CouchDB中，可以集中进行问题检查和分析。 Graphite网站使用Graphite采集网站实时信息并统计。从请求每个模块/行为到Memcached的命中和未命中、RabbitMQ状态监控以及Unix负载等等。Graphite服务平均每分钟有4800次更新操作。实践已经证实要监测网站发发生什么是非常有用的，它的简单文本协议和绘图功能可以方便地即插即 用的方式用于任何需要监控的系统上。 一件很酷的事情是使用Graphite同时监控了网站的两个版本。一月份部署了Symfony框架新 版本，以前代码作为一个备份部署。这就意味着网站可能会面临性能问题。因此可以使用Graphite来对两个版本在线进行对比。发现新版本上的Unix负载表较高，于是使用XHProf对两个版本进行性能分析，找出问题所在。 Red5网站为用户也提供了两种类型的视频服务，一种是用户自己上载的视频，另外一种是视频聊天，用户视频互动和分享。到2009年年中，每月为用户提供17TB的流量服务。 TsungTsung 是一个Erlang编写的分布式基准分析工具。在Poppen.de网站中主要用于HTTP基准分析、MySQL与其他存储系统(XtraDB)的对比分析。用一个系统记录了主要的MySQL服务器的流量，再转换成Tsung的基准会话。然后对该流量进行回放，由Tsung产生数以千计的并发用户访问实验 室的服务器。这样就可以在实验环境中与真实场景非常接近。","categories":[{"name":"转载","slug":"reproduce","permalink":"http://yoursite.com/categories/reproduce/"}],"tags":[]},{"title":"酷狗音乐API，关键字搜索歌曲/获取音乐原始路径","slug":"2015/08/187","date":"2015-08-26T16:00:00.000Z","updated":"2015-08-26T16:00:00.000Z","comments":true,"path":"2015/08/187.html","link":"","permalink":"http://yoursite.com/2015/08/187.html","excerpt":"","text":"酷狗API，可根据关键字搜索歌曲及获取音乐原始路径 附根据该API，做的一个简单的音乐网站：http://music.flc.ren/ 代码托管地址：https://code.csdn.net/flc1125/kugou-api &lt;?php /** * 酷狗API类 * * @author Flc &lt;2015-08-27 22:51:24&gt; */require_once 'http.class.php';class Kugou&#123; const LIST_URL = 'http://lib9.service.kugou.com/websearch/index.php?page=&#123;page&#125;&amp;keyword=&#123;keyword&#125;&amp;cmd=100&amp;pagesize=&#123;pagesize&#125;'; const MUSIC_URL = 'http://m.kugou.com/app/i/getSongInfo.php?hash=&#123;hash&#125;&amp;cmd=playInfo'; protected static $http = null; /** * 初始化 */ function __construct() &#123; if (self::$http == null) &#123; self::$http = new http(); &#125; &#125; /** * 获取列表 * * @param string $keyword 关键字 * @param integer $page 当前页 * @param integer $pagesize 每页获取数量 * @return array|false */ public function getList($keyword, $page = 1, $pagesize = 10) &#123; $url = str_replace(array('&#123;page&#125;', '&#123;keyword&#125;', '&#123;pagesize&#125;'), array($page, $keyword, $pagesize), self::LIST_URL); $json = self::$http-&gt;http_gets($url); if(!$json) return false; $resp = json_decode($json, true); return $resp; &#125; /** * 获取音乐地址 * @param string $hash 音乐hash码 * @return string|false */ public function getMusic($hash) &#123; $url = str_replace(array('&#123;hash&#125;'), array($hash), self::MUSIC_URL); $json = self::$http-&gt;http_gets($url); if(!$json) return false; $resp = json_decode($json, true); return $resp; &#125;&#125;?&gt;","categories":[{"name":"PHP","slug":"php","permalink":"http://yoursite.com/categories/php/"},{"name":"分享","slug":"php/share","permalink":"http://yoursite.com/categories/php/share/"}],"tags":[]},{"title":"PHP 命名空间","slug":"2015/08/181","date":"2015-08-02T16:00:00.000Z","updated":"2015-08-02T16:00:00.000Z","comments":true,"path":"2015/08/181.html","link":"","permalink":"http://yoursite.com/2015/08/181.html","excerpt":"","text":"PHP中的命名空间是什么？官方解释在此： 命名空间概述 命名空间用一句话说，就是：把 类、函数、变量 等放到子文件夹中去，以避免命名冲突。 被隐藏的第一个在每个 PHP 文件的最开始定义命名空间： &lt;?phpnamespace TinyLara\\TinyRoute;class TinyRoute &#123; ...&#125; 在定义命名空间之后引入命名空间： &lt;?phpnamespace TinyLara\\TinyRoute;use TinyLara\\TinyView\\TinyView;class TinyRoute &#123; ...&#125; 上述代码中， namespace TinyLara\\TinyRouteuse TinyLara\\TinyView\\TinyView 这两行的真实地址是： \\TinyLara\\TinyRoute、\\TinyLara\\TinyView\\TinyView，顶级命名空间标识（第一个 \\ ）被省略了。 被隐藏的别名在上一节中中，这一行代码 use TinyLara\\TinyView\\TinyView 的完整写法应该是： use \\TinyLara\\TinyView\\TinyView as TinyView 如果不指定别名，那就默认别名为类名，注入当前命名空间。 使用绝对路径直接调用&lt;?phpnamespace TinyLara\\TinyRoute;class TinyRoute&#123; public function foo() &#123; return \\TinyLara\\TinyView\\TinyView::fuck(); &#125;&#125; 使用绝对路径调用类时顶级命名空间标识（第一个 \\ ）不能省略。（很多人都在这个地方迷惑了） 命名空间的实际价值命名空间的存在是为了解决下面两个问题： 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。 为很长的标识符名称（通常是为了缓解第一类问题而定义的）创建一个别名（或简短）的名称，提高源代码的可读性。 目前非常流行的 Composer 就是一个基于命名空间的包管理器/依赖管理器，同样，Laravel 能达到今天的成功，很大程度上也是因为PHP5.3的普及，生恰逢时。你可以在 https://packagist.org/ 上下载到各种 composer 包，类似于 yum、npm或者gem。 同一命名空间下的类可以任意相互调用&lt;?phpnamespace A;class ClassA&#123; public static function test() &#123; echo 'Success!'; &#125;&#125; &lt;?phpnamespace A;class ClassB&#123; public static function test() &#123; ClassA::test(); &#125;&#125; 直接调用即可。 原文：https://lvwenhan.com/php/401.html","categories":[{"name":"PHP","slug":"php","permalink":"http://yoursite.com/categories/php/"},{"name":"转载","slug":"php/reproduce","permalink":"http://yoursite.com/categories/php/reproduce/"}],"tags":[]},{"title":"Git 常用命令整理","slug":"2015/08/174","date":"2015-08-01T16:00:00.000Z","updated":"2015-08-01T16:00:00.000Z","comments":true,"path":"2015/08/174.html","link":"","permalink":"http://yoursite.com/2015/08/174.html","excerpt":"","text":"初始化配置# 配置使用git仓库的人员姓名git config –global user.name “Your Name Comes Here”# 配置使用git仓库的人员emailgit config –global user.email you@yourdomain.example.com# 配置到缓存 默认15分钟git config –global credential.helper cache# 修改缓存时间git config –global credential.helper ‘cache –timeout=3600’git config –global color.ui truegit config –global alias.co checkoutgit config –global alias.ci commitgit config –global alias.st statusgit config –global alias.br branchgit config –global core.editor \"mate -w\" # 设置Editor使用textmategit config -1 # 列举所有配置# 用户的git配置文件~/.gitconfig 查看、添加、提交、删除、找回，重置修改文件git help &lt;command&gt; # 显示command的helpgit show # 显示某次提交的内容git show $idgit co — &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; –cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset — . # 从暂存区恢复到工作文件git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt;git ci .git ci -a # 将git add, git rm和git ci等操作都合并在一起做git ci -am “some comments”git ci –amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象git revert HEAD # 恢复最后一次提交的状态 查看文件diffgit diff &lt;file&gt; # 比较当前文件和暂存区文件差异git diffgit diff &lt;$id1&gt; &lt;$id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较git diff –staged # 比较暂存区和版本库差异git diff –cached # 比较暂存区和版本库差异git diff –stat # 仅仅比较统计信息 查看提交记录git loggit log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log –stat #查看提交统计信息 tigMac上可以使用tig代替diff和log，brew install tig 取得Git仓库# 初始化一个版本仓库git init# Clone远程版本库git clone git@xbc.me:wordpress.git# 添加远程版本库origin，语法为 git remote add [shortname] [url]git remote add origin git@xbc.me:wordpress.git# 查看远程仓库git remote -v```bash## 提交你的修改```bash# 添加当前修改的文件到暂存区git add .# 如果你自动追踪文件，包括你已经手动删除的，状态为Deleted的文件git add -u# 提交你的修改git commit –m “你的注释”# 推送你的更新到远程服务器,语法为 git push [远程名] [本地分支]:[远程分支]git push origin master# 查看文件状态git status# 跟踪新文件git add readme.txt# 从当前跟踪列表移除文件，并完全删除git rm readme.txt# 仅在暂存区删除，保留文件在当前目录，不再跟踪git rm –cached readme.txt# 重命名文件git mv reademe.txt readme# 查看提交的历史记录git log# 修改最后一次提交注释的，利用–amend参数git commit –amend# 忘记提交某些修改，下面的三条命令只会得到一个提交。git commit –m &amp;quot;add readme.txt&amp;quot;git add readme_forgottengit commit –amend# 假设你已经使用git add .，将修改过的文件a、b加到暂存区# 现在你只想提交a文件，不想提交b文件，应该这样git reset HEAD b# 取消对文件的修改git checkout –- readme.txt 查看、切换、创建和删除分支git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br –merged # 查看已经被合并到当前分支的分支git br –no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebasegit merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master –no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于：git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用)git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply –check ../sync.patch #测试补丁能否成功 Git暂存管理git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区 Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地git pull –no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co –track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 基本的分支管理# 创建一个分支git branch iss53# 切换工作目录到iss53git chekcout iss53# 将上面的命令合在一起，创建iss53分支并切换到iss53git chekcout –b iss53# 合并iss53分支，当前工作目录为mastergit merge iss53# 合并完成后，没有出现冲突，删除iss53分支git branch –d iss53# 拉去远程仓库的数据，语法为 git fetch [remote-name]git fetch# fetch 会拉去最新的远程仓库数据，但不会自动到当前目录下，要自动合并git pull# 查看远程仓库的信息git remote show origin# 建立本地的dev分支追踪远程仓库的develop分支git checkout –b dev origin/develop Git远程仓库管理git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址)git remote rm &lt;repository&gt; # 删除远程仓库## 创建远程仓库git clone –bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git –bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支# 也可以命令设置跟踪远程库和本地库git branch –set-upstream master origin/mastergit branch –set-upstream develop origin/develop","categories":[{"name":"学习","slug":"study","permalink":"http://yoursite.com/categories/study/"},{"name":"分享","slug":"study/share","permalink":"http://yoursite.com/categories/study/share/"}],"tags":[]},{"title":"win7系统下VirtualBox升级后不能为虚拟电脑打开一个新任务0x80004005的解决方法","slug":"2015/07/68","date":"2015-07-30T05:17:00.000Z","updated":"2015-07-30T05:17:00.000Z","comments":true,"path":"2015/07/68.html","link":"","permalink":"http://yoursite.com/2015/07/68.html","excerpt":"","text":"问题最近 VirtualBox 虚拟机软件更新的频率越来越快，不少用户都升级到了 VirtualBox 4.326 版本，结果在升级后发现原来创建的虚拟机打不开了，提示信息为： 不能为虚拟电脑 win7 打开一个新任务.Unable to load R3 module C:\\Program Files\\Oracle\\VirtualBox/VBoxDD.DLL (VBoxDD): GetLastError=1790 (VERR_UNRESOLVED_ERROR).返回 代码:E_FAIL (0x80004005)组件:Console界面:IConsole &#123;8ab7c520-2442-4b66-8d74-4ff1e195d2b6&#125; 解决 出现这样的情况该如何解决呢？ 如果不是升级导致的 那么可以看这编文章：http://www.xitonghe.com/jiaocheng/diannao-196.html 通过分析日志，我们将问题锁定在 win7系统的主题核心文件“uxtheme.dll”其实我们将已经破解的win7系统主题核心文件还原，即可打开虚拟机了。 操作步骤： 下载未破解的win7主题核心文件“themeui.dll”，“themeservice.dll”，“uxtheme.dll”三个文件； 下载地址：http://www.xitonghe.com/rjxz/xtgj/patch-xiazai-278.html 然后在WinPE下将这三个文件覆盖到C:\\windows\\system32\\文件夹下即可。 这里为了大家方便，小编给大家准备了主题破解工具（带还原功能），下载后将三个文件的备份（backup后缀）复制到C:\\windows\\system32\\目录，然后运行“UniversalThemePatcher-x64.exe” 这时软件会提示已经破解过，到主界面后，我们分别还原三个文件。 OK，到这里就解决完毕了…","categories":[{"name":"运维","slug":"devops","permalink":"http://yoursite.com/categories/devops/"}],"tags":[]},{"title":"罗生门的谎言","slug":"2015/07/33","date":"2015-07-24T12:47:00.000Z","updated":"2015-07-24T12:47:00.000Z","comments":true,"path":"2015/07/33.html","link":"","permalink":"http://yoursite.com/2015/07/33.html","excerpt":"","text":"大盗遇上武士夫妇，设计擒住武士，然后将妻子骗到武士面前，强暴了她，最后武士死去。 武士怎么死的，这成了情节上最大的悬念，但在影片中，这个真实的悬念相对于谎言所制造的悬念，差不多完全可以忽略了。 大盗说，他本来没有动邪念，但一阵清风让他看到女子的美貌，于是动了邪念。本来他不想杀武士，但女子被强暴后，居然不仅答应跟他走，还要他杀掉武士，于是他和武士奋勇大战二十多回合，最后将武士杀死。然而，那女子却乘机逃跑了。 大盗的陈述中，突出了他的骁勇。 女子说，她被强暴后，大盗走了，她哭着抱住了丈夫，但却发现，丈夫非常冷漠，看着她的眼神中充满了蔑视、嘲弄和愤怒，比大盗更可怕，她拿着匕首扑上去让丈夫杀他，但晕了过去，醒来后发现丈夫胸口上插着匕首死去了。 女子的陈述中，突出了她的无助。 死去的武士借女巫的口也在衙门上做了陈述。他说，大盗强暴妻子后，妻子求大盗杀死他，这个要求令大盗震惊，大盗转而去杀妻子，但她逃跑了，大盗转回来割开了武士身上的绳索，但他心冷至极，于是自杀了。 武士的陈述中，突出了他的心疼。 这是衙门上的陈述，但在破败的罗生门边，作为最早发现武士死亡现场的证人，樵夫说出了自己的陈述。 樵夫说，女子被强暴后，一直埋头地下痛哭，而大盗求她跟自己走。女子哭了很久后，突然跑去割开丈夫身上的绳索，又跑回来爬在地上痛哭。大盗恍然大悟，认为是女子要他和武士决斗。但武士拒绝决斗，因为她已是“妓女”，不值得。他还嘲讽妻子为什么不自杀。武士的说法刺激了大盗，他也失去了对女子的热情，想转身离开。这时，一直只是痛哭的女子突然站起来，用尖利的语言狠狠地嘲讽两个男人懦弱，终于激得两个男人展开决斗，两个怕死鬼非常可笑地打斗了很多回合后，大盗幸运地将武士杀死。 樵夫的陈述直接驳倒了武士。本来认为以为，死去的人不必说谎了，但樵夫作为目击征人，说死人也会说谎。 但樵夫一样也撒了谎。原来，他偷走了现场的一把镶着珍珠的匕首，为了掩饰这一点，他也撒了谎。 四个版本的陈述，能相信谁？显然，谁的都不可全相信。所以，见证了审判过程的僧人说：“如果不能信任别人，这个世界和地狱有什么分别？” 如果说，一旦有人撒谎，我们就不能信任这个人。那么，这个世界会彻底是一个地狱。因为，谎言实在太普遍了。 美国马萨诸塞州大学的心理学家罗伯特·费尔德曼做过一个实验。人们在日常交谈时，他带上隐蔽的摄像机录下现场情景。然后，实验人员一边观看录像带，一边计算人们在交谈中说谎的次数。统计结果令人吃惊：人们平均每10分钟就会说3个谎言。 美国新泽西州约翰逊医学院的刘易斯博士的研究也显示了这一点。他要求被调查者反省自己每天撒谎的次数，而被调查者承认，他们平均每天最少撒谎次数是25次。这个数字让被调查者感到吃惊不已，但可以料定，他们真正说谎的时候比这个数字要高得多，毕竟这个调查的依据是被调查者的“主观陈述”。 习惯上，我们认为孩子是真诚的天使。但幼小的孩子，会出于心理需要把想象描述成事实。美国一名幼师被她执教的孩子们描述成恶魔，说她对他们实施了难以想象的虐待和性骚扰，如在男孩们的阳具上涂抹花生酱，然后她去添。大人们开始信以为真，但后来发现这全是孩子们的幻想。 这是不是比《罗生门》更可怕的谎言世界？ 要回答这个问题，首先要回答一个问题——人们为什么撒谎？ 这个答案很简单：因为我说出真话，你不能接受，所以我只好撒谎。 前两天，一个妈妈对我说，她儿子总对她撒谎，让她非常愤怒，她想尽办法希望儿子说真话，但显然儿子就是不肯说。 我问她：“儿子对你说了真话后，你能接受吗？以前他说真话时，你有接受的能力吗？” 她陷入了沉思，想了一会儿后说，的确，很多时候，当儿子说了真话后，她没法接受，会对他大加训斥。 她这样做，儿子只好撒谎，因为这个妈妈没有接受他的真话的能力。他撒谎既是为了保护他自己，也是为了保护妈妈。 谎言看起来有两种：自欺，即对自己撒谎；欺人，即对别人撒谎。但这两种谎言其实是一回事。自欺，即自己欺骗自己，这从逻辑上是不成立的，更准确的解释是“内在的小孩”对“内在的父母”撒谎，即内心的一部分“我”对另外一部分“我”撒谎，所谓自欺其实也是一种内在人际关系的欺人。 黑泽明的这部影片中，核心点在于女子，一方面是两个男人对她的态度大有问题，另一方面是她自己对两个男人的态度也很古怪。 大盗强暴女子时，黑泽明着意描绘了一个细节：她的手一开始是挣扎的，但慢慢地放开了，最后还抱住了大盗的背，而另一只手中的匕首也悄然落地。这个细节显示，这个女子从被强暴中得到了快感。 一些细心的观众关注到了这个细节，并发表评论说，这个女子开始享受被强暴的欢娱了。假设这个女子要和这些细心人对话，而这些细心人并没有看到这个细节，那么可以预料的是，这个女子势必会对这些细心人撒谎，她会刻意隐瞒自己在被强暴中有快感的事实，而只将自己描绘成一个彻底的受害者。 这些细心人知道真相后，势必会谴责这个女子撒谎。然而，他们真有能力理解并接受这个女子的真相吗？ 在被强暴中得到快感，这几乎是一种必然的事情。不管一个女子意志上多么不情愿，当被强暴时，一定会有或多或少的生理快感产生，这不是由这个女子的意志所能决定的。 强暴带给女子的心理创伤，有相当一部分是，她们不能原谅自己，居然在这种时候会有快感产生，于是她们自己会谴责自己“贱”。因为这种自我谴责，哪怕没有别人知道她被强暴的事实，她也容易产生自暴自弃的念头，很多女子被强暴后沦为妓女，其中一个原因就是因为不能原谅自己这时有快感产生。 给遭遇强暴的女子做心理治疗，就势必要面对这一点。假若这个女子感觉到心理医生不能接受她有快感产生的事实，那么她一定会对心理医生撒谎，这样治疗效果就不可能太好。但假若这个心理医生深深地懂得这一点，让这个女子感觉到，无论她什么，心理医生都能包容她、理解她、接受她，那么她会把她最为羞耻的这一点说出来，并学会自我接纳，从而得到更彻底的治疗。黑泽明的多部影片都给我缺乏宽容的感觉，这不难理解，他生于一个武士家庭，而武士道是一个非常苛刻的生命哲学，太过于强调人的自由意志。然而，人的自由意志很有限。譬如，身体的快感就不是我们的自由意志所能左右的，我们不能做到在性关系想让自己有快感就有快感，也不能做到想让自己没快感就没快感。假若懂得这一点，一个被强暴的女子就可以理解，她被强暴并产生一定的快感，这和她意志上抗拒强暴并不矛盾，前者她不能左右，而后者她能左右。 《罗生门》中，女子撒了谎。但假设她不撒谎，她百分百地坦诚，试问有谁能理解能接受？估计她有快感这一点，影片中的所有人都不能接受。 这也就罢了，在当时的大男子主义盛行的社会，仅仅女子被强暴这一点，就没有多少人能接受。显然武士不能接受，而当武士说妻子是“妓女”时，大盗也不能接受了。既然大家都不能接受她的真相，她只好撒谎。 武士撒谎也很容易理解。武士道倡导绝对的坚硬，但他先很窝囊地被大盗算计了，接着妻子又在自己眼前被强暴，这两件事彻底摧毁他的自信。他要想继续有颜面地生存下去，只好试着让这件事对自己影响降到最低点。为此，他会蔑视妻子，因他首先蔑视了自己；他会希望妻子死去，因他希望自己死去。 假若没有一个锋利的、绝对化的武士道精神在他心中，他是否就可以比较宽容地对待妻子在自己眼前被强暴的事实，是否就可以抱慰她的脆弱，和她一起哭泣，一起面对这件事情。再如樵夫，假若他拿走匕首这件事可以不被追究，他没有阻止悲剧发生的软弱不被追求，那么他就不必撒谎了。 一个社会的道德标准越锋利、越苛刻，人们就容易撒谎。英国维多利亚时代追求清心寡欲，但这一时代反而出现了最出色的黄色小说。那些一流的小说家也会装得正人君子一样，四处撒谎，但一转身便成了“最下流”的家伙。这是同一个道理。 谁在制造最大的谎言呢？譬如，一对父母，因为孩子撒谎，而把孩子活活打死，他们事后痛哭流涕地说，他们太爱他了，所以特别恨他撒谎，而一个社会也似乎理解了这对父母的苦衷。那么，究竟谁的谎言更重？显然是父母，是社会，杀死了孩子，居然还可以说爱他，这是最大的恬不知耻了。 回到《罗生门》上，当丈夫和强盗都不能接受一个受辱的女子时，他们才是谎言的制造者。 同样的道理，当我们谴责一个人撒谎时，我们要好好问问自己，假若对方说了实话，我们能否接受。 黑泽明的影片《乱》和《罗生门》一样，其道德标准也是相当锋利的，结果导致了最可怕的恶——亲人相残——产生。 不过，《罗生门》中也不是全然没有温暖。一直站在谴责者角度的樵夫，最后出现了自省，说：“我才是那个应该感到羞耻的人，我没理解自己的灵魂。” 不仅如此，他还理解了那对未露面的父母遗弃婴儿的苦衷，并抱起了被遗弃的婴儿。 于是，心地单纯的僧人说，感谢你，让我恢复了对人类灵魂的信心。 不仅如此，在我看来，那个一直露着狰狞面孔的乞丐也是可以谅解的，他是行了恶，剥了包着婴儿的和服，但他并没有再去剥这个婴儿的内衣。一个一无所有的乞丐，他的生与死可能就寄托在一件和服上，这时别人没有太大的资格去谴责他的良心。 他的那副狰狞面孔，可能和大盗一样，只是为了恐吓人的，但他的内心，是惶恐至极，脆弱至极。 谎言可怕，但更可怕的是不原谅、不理解，并由此认为“为了生存，没有什么是不可以的”。这句话，乞丐可以说，但坐在办公室的空调下，敲出这样的字来，是需要好好反省一下，为什么自己的内心如此残忍。 谎言的另一面并非是真诚，而是宽容，宽容是能减少谎言的唯一道路。","categories":[{"name":"分享","slug":"share","permalink":"http://yoursite.com/categories/share/"}],"tags":[]},{"title":"Thinkphp防止大量访问，造成网站压力大","slug":"2015/07/17","date":"2015-07-23T11:08:00.000Z","updated":"2015-07-23T11:08:00.000Z","comments":true,"path":"2015/07/17.html","link":"","permalink":"http://yoursite.com/2015/07/17.html","excerpt":"","text":"该方法利用 S 缓存方法 &lt;?php// 防止大量访问，造成服务器压力大function noHacker() &#123; $time = 5; //每多少秒 $num = 30; //最多访问次数 $lists = S(\"noHacker\"); $ip = getIp(); $sid = session_id(); $key = md5($ip.$sid); if (!$lists[$key]) &#123; $lists[$key] = array('time' = &gt;time(), \"num\" = &gt;0, ); S('noHacker', $lists); &#125; else &#123; $data = $lists[$key]; if (time() &gt; $data[\"time\"] + $time) &#123; $lists[$key] = array('time' = &gt;time(), \"num\" = &gt;0, ); S('noHacker', $lists); //重置 &#125; else &#123; if ($data['num'] &gt;= $num) &#123; exit(\"您访问过于频繁，请稍后在访问！\"); &#125; else &#123; $lists[$key] = array('time' = &gt;time(), \"num\" = &gt;$data['num'] + 1, ); S('noHacker', $lists); //添加 &#125; &#125; &#125;&#125;","categories":[{"name":"后端","slug":"backend","permalink":"http://yoursite.com/categories/backend/"}],"tags":[]},{"title":"《黑羊》——卡尔维诺","slug":"2015/07/4","date":"2015-07-23T04:01:00.000Z","updated":"2015-07-23T04:01:00.000Z","comments":true,"path":"2015/07/4.html","link":"","permalink":"http://yoursite.com/2015/07/4.html","excerpt":"","text":"从前有个国家，里面人人是贼。 一到傍晚，他们手持万能钥匙和遮光灯笼出门，走到邻居家里行窃。破晓时分，他们提着偷来的东西回到家里，总能发现自己家也失窃了。 他们就这样幸福地居住在一起。没有不幸的人，因为每个人都从别人那里偷东西，别人又再从别人那里偷，依次下去，直到最后一个人去第一个窃贼家行窃。该国贸易也就不可避免地是买方和卖方的双向欺骗。政府是个向臣民行窃的犯罪机构，而臣民也仅对欺骗政府感兴趣。所以日子倒也平稳，没有富人和穷人。 有一天－－到底是怎么回事没人知道－－总之是有个诚实人到了该地定居。到晚上，他没有携袋提灯地出门，却呆在家里抽烟读小说。 贼来了，见灯亮着，就没进去。 这样持续了有一段时间。后来他们感到有必要向他挑明一下，纵使他想什么都不做地过日子，可他没理由妨碍别人做事。他天天晚上呆在家里，这就意味着有一户人家第二天没了口粮。 诚实人感到他无力反抗这样的逻辑。从此他也像他们一样，晚上出门，次日早晨回家，但他不行窃。他是诚实的。对此，你是无能为力的。他走到远处的桥上，看河水打桥下流过。每次回家，他都会发现家里失窃了。 不到一星期，诚实人就发现自己已经一文不名了；他家徒四壁，没任何东西可吃。但这不能算不了什么，因为那是他自己的错；不，问题是他的行为使其他人很不安。因为他让别人偷走了他的一切却不从别人那儿偷任何东西；这样总有人在黎明回家时，发现家里没被动过－－那本该是由诚实人进去行窃的。 不久以后，那些没有被偷过的人家发现他们比人家就富了，就不想再行窃了。更糟的是，那些跑到诚实人家里去行窃的人，总发现里面空空如也，因此他们就变穷了。 同时，富起来的那些人和诚实人一样，养成了晚上去桥上的习惯，他们也看河水打桥下流过。 这样，事态就更混乱了，因为这意味着更多的人在变富，也有更多的人在变穷。 现在，那些富人发现，如果他们天天去桥上，他们很快也会变穷的。他们就想：“我们雇那些穷的去替我们行窃吧。”他们签下合同，敲定了工资和如何分成。自然，他们依然是贼，依然互相欺骗。但形势表明，富人是越来越富，穷人是越来越穷。 有些人富裕得已经根本无须亲自行窃或雇人行窃就可保持富有。但一旦他们停止行窃的话，他们就会变穷，因为穷人会偷他们。因此他们又雇了穷人中的最穷者来帮助他们看守财富，以免遭穷人行窃，这就意味着要建立警察局和监狱。 因此，在那诚实人出现后没几年，人们就不再谈什么偷盗或被偷盗了，而只说穷人和富人；但他们个个都还是贼。 唯一诚实的只有开头的那个人，但他不久便死了，饿死的。","categories":[{"name":"分享","slug":"share","permalink":"http://yoursite.com/categories/share/"}],"tags":[]}]}